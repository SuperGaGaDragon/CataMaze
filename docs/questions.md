# Development Questions & Uncertainties

记录开发过程中遇到的问题、不确定性和设计决策。

---

## Stage 0: Requirements & Scaffolding

### Q1: 数据库选择
**问题**: 使用PostgreSQL还是SQLite？

**决策**: 支持两者
- 生产环境: PostgreSQL (可扩展性)
- 开发/测试: SQLite (便捷性)

**理由**: 提供灵活性，通过DATABASE_URL环境变量切换

---

## Stage 1: Core Engine MVP

### Q2: 视野范围大小
**问题**: 玩家视野应该多大？

**决策**: 5x5局部视野

**理由**:
- 足够提供战术信息
- 不会泄露过多地图信息
- 符合Roguelike传统
- 性能友好

### Q3: 弹药回复机制
**问题**: 如何平衡弹药消耗和回复？

**决策**: 最大3发，每2 tick自动回复1发

**理由**:
- 避免无限射击
- 鼓励策略性使用弹药
- 每2 tick回复保证持续战斗能力

### Q4: 子弹速度
**问题**: 子弹应该多快？

**决策**: 每tick移动1格

**理由**:
- 简单易实现
- 给玩家反应时间
- 与游戏节奏匹配

---

## Stage 2: Backend API + Storage

### Q5: API设计风格
**问题**: 使用RESTful还是GraphQL？

**决策**: RESTful

**理由**:
- 更简单直接
- 适合游戏操作语义
- FastAPI原生支持更好

### Q6: 游戏状态存储
**问题**: 每次tick都保存到数据库吗？

**决策**: 是，每次tick都保存

**理由**:
- 保证数据持久性
- 支持游戏恢复
- 可以回放历史

**性能考虑**:
- 使用批量插入
- 考虑异步写入
- 活跃游戏缓存在内存

### Q7: Watch模式安全性
**问题**: 如何防止玩家在正常游戏中作弊查看完整地图？

**决策**: 使用 `-watch` 后缀区分

**理由**:
- 简单有效
- 明确区分开发和正常模式
- 403 Forbidden防止误用

---

## Stage 3: Terminal Frontend

### Q8: 命令行参数设计
**问题**: 使用交互式还是命令行参数？

**决策**: 命令行参数

**示例**: `catamaze new --map default`

**理由**:
- 更符合CLI工具习惯
- 易于脚本化
- 清晰的命令语义

### Q9: 多动作队列上限
**问题**: 应该限制队列大小吗？

**决策**: 不限制（或限制在100）

**理由**:
- 允许玩家预先规划
- 服务器会处理过长队列
- 提供便利性

---

## Stage 4: UI Frontend

### Q10: UI技术栈
**问题**: 使用框架（React/Vue）还是原生JS？

**决策**: 原生HTML/CSS/JS

**理由**:
- 项目简单，不需要框架复杂性
- 减少依赖
- 更快加载
- 易于理解和维护

### Q11: 实时更新机制
**问题**: 使用WebSocket还是轮询？

**决策**: 轮询（每500ms）

**理由**:
- 实现简单
- 回合制游戏不需要实时性
- 避免WebSocket连接管理复杂性

**未来**: 可升级到WebSocket

---

## Stage 5: RL Agent Framework

### Q12: RL算法选择
**问题**: 使用哪种RL算法？

**决策**: 框架支持但不强制，预留PPO/DQN接口

**理由**:
- 提供灵活性
- PPO适合连续动作
- DQN适合离散动作

**当前状态**: 使用启发式策略，预留训练接口

### Q13: 特征编码方式
**问题**: 如何编码观察为特征向量？

**决策**:
- 视野网格: 5x5x4 (wall, entity, item, bullet)
- 自身状态: hp, ammo, position
- 实体信息: 相对位置、距离
- 声音: 8方向编码

**理由**:
- 包含所有关键信息
- 适合神经网络输入
- 可扩展性好

### Q14: Persona系统实现
**问题**: 硬编码还是配置文件？

**决策**: JSON配置文件

**位置**: `backend/personas/*.json`

**理由**:
- 易于修改和扩展
- 不需要重新编译
- 支持用户自定义
- 清晰的行为参数

---

## Stage 6: Polish & Optimization

### Q15: 代码行数限制
**问题**: 200行限制是否过于严格？

**决策**: 严格遵守200行

**理由**:
- 强制模块化
- 提高可读性
- 鼓励单一职责

**实施**: 所有文件均<200行，部分文件拆分模块

### Q16: 文档完整性
**问题**: 需要多详细的文档？

**决策**:
- 用户文档: 完整API、使用指南
- 开发文档: 规范、系统说明
- 实现文档: 每阶段总结

**理由**:
- 帮助新用户快速上手
- 方便后续维护
- 记录设计决策

---

## 未解决的问题

### U1: 大规模并发
**问题**: 如何扩展到1000+并发游戏？

**可能方案**:
- Redis缓存层
- 游戏状态分片
- 多进程/多机部署
- 数据库读写分离

**状态**: 待评估

### U2: AI训练效率
**问题**: 如何高效训练RL Agent？

**可能方案**:
- GPU加速
- 分布式训练
- 经验回放优化
- 自对弈训练

**状态**: 框架已预留接口

### U3: 地图平衡性
**问题**: 如何保证地图公平性？

**可能方案**:
- 地图生成算法验证
- 自动平衡检测
- 社区投票系统

**状态**: 当前使用手工设计地图

---

## 设计权衡

### T1: 性能 vs 功能
**权衡**: 简单实现 vs 高性能优化

**选择**: 优先简单实现，预留优化空间

**理由**:
- MVP快速迭代
- 避免过度优化
- 根据实际需求优化

### T2: 灵活性 vs 简洁性
**权衡**: 配置化 vs 硬编码

**选择**: 关键参数配置化（Persona, 地图）

**理由**:
- 平衡可维护性和灵活性
- 核心逻辑保持简洁

### T3: 实时性 vs 复杂性
**权衡**: WebSocket vs 轮询

**选择**: 轮询（当前）

**理由**:
- 回合制游戏不需要强实时性
- 降低架构复杂度
- 可平滑升级

---

## 经验教训

### L1: 模块化的重要性
严格的200行限制强制了良好的模块化，提高了代码质量。

### L2: 文档先行
每个阶段的文档帮助明确需求，减少返工。

### L3: 测试驱动
早期测试发现了多个边界情况问题。

### L4: 配置分离
环境变量和配置文件分离提高了部署灵活性。

---

**最后更新**: 2026-01-27
**维护者**: Development Team
